# 前端经典问题题解

## 作用

* 常见经典的前端问题解决方案

## 1、判断稀疏数组

* 概念：即数组中又空槽位，例`const arr = [1,,,2, 3, 4,,,];`，该数组在控制台打印结果为`[ 1, <2 empty items>, 2, 3, 4, <3 empty items> ]`，**<font color='red'>空槽位上的索引读取结果为undefined，但是如果数组索引对应值为undefined，则读取结果也是undefined，但是二者不一样</font>**，即如果对应位置的值为undefined，则数组不是稀疏数组。

> 注意：
>
> 1. 空槽位索引值读取结果为undefined，但是索引上值为undefined时，不是空槽位；
> 2. 不能通过长度判断，`arr.length`不一定就不等于`Object.keys(arr).length`，因为可以给数组对象arr添加任意属性，从而影响``Object.keys()`函数的结果。

* 解决方案：

  ```javascript
  const isSparseArray = (arr) => {
      if (!Array.isArray(arr)) {
          throw new Error('arr must be an Array!');
      }
      for (let i = 0; i < arr.length; i++) {
          if (!arr.hasOwnProperty(i)) { // 不能使用 arr[i] === undefined 进行判断，使用hasOwnProperty函数判断下标是否存在
              return true;
          }
      }
      return false;
  };
  ```


## 2、使用JavaScript实现LRU缓存算法

* 概念：LRU，即Least Recently Used，即最久未使用。LRU缓存算法即为淘汰策略为优先淘汰缓存中最久未使用的数据。

```javascript
class LRUCache {
  #cache;
  constructor(capacity) {
    this.capacity = capacity;
    this.#cache = new Map();
  }
  has(kay){
    return this.#cache.has(kay);
  }
  get(kay){
    if (!this.#cache.has(kay)) {
      return;
    }
    const value = this.#cache.get(kay);
    this.#cache.delete(kay);
    this.#cache.set(kay, value);
    return value;
  }
  put(kay, value){
    if (!this.#cache.has(kay)) {
      this.#cache.delete(kay);
    } else if (this.#cache.size() >= this.capacity) {
      this.#cache.delete(this.#cache.keys().next().value);
    }
    this.#cache.set(kay, value);
  }
}
```

## 3、优化动态规划空间复杂度

**举例1：** 求斐波那契数列指定位置值

| 1    | 1    | 2    | 3    | 5    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- |

* 常用解法

  ```javascript
  /**
   * 求菲波那切数列第n位
   */
  function fibonacci(n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    const arr = [1, 1];
    for (let i = 2; i < n; i++) {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[n - 1];
  }
  ```

* 使用移位指针优化空间复杂度

  ```javascript
  /**
   * 求菲波那切数列第n位
   */
  function fibonacci(n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    let p1 = 1, p2 = 1;
    for (let i = 2; i < n; i++) {
      let temp = p1 + p2;
      p1 = p2;
      p2 = temp;
    }
    return p2;
  }
  ```

  一直需要的都只是两位数而已，因为只要知道前两位就可以求取下一位，因此只需要不断推导累加即可，不需要构建一个长度为n的数组。

**举例2：** 机器人只能向左或是向下移动，求下列机器人到终点的所有路线。

| 机器人 |      |      |      |      |      |      |
| :----: | ---- | ---- | ---- | ---- | ---- | :--: |
|        |      |      |      |      |      |      |
|        |      |      |      |      |      | 终点 |

常规方法为创建一个`m*n`的二维数组，数组每一个元素为机器人走到该点的路径数量，所以空间复杂度为`O(m*n)`。

|  1   |  1   |  1   |  1   |  1   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |  5   |  6   |  7   |
|  1   |  3   |  6   |  10  |  15  |  21  |  28  |

观察数组发现，整个迭代过程中，除了第一行第一列恒为1，其余的只需要相邻的前两个元素即可，因此可以将二维数组转为一维数组，下一行的值等于上一个元素+自身的值。

```javascript
function uniquePaths(m, n) {
    if (m == 1 || n == 1) {
        return 1;
    }
    let minLen = Math.min(m, n);
    let maxLen = Math.max(m, n);
    let dp = new Array(minLen).fill(1);
    for (let i = 1; i < maxLen; i++) {
        for (let j = 1; j < minLen; j++) {
            dp[j] += dp[j - 1];
        }
    }
    return dp[minLen - 1];
}
```

## 4、可重试的请求

```js
/**
 * 函数描述：发出请求，如果失败则最多重试指定次数，返回Promise
 * @param {string} url 请求地址
 * @param {number} maxCount 最大重试次数
 */
function request(url, maxCount = 5) {
  return fetch(url).catch(error => maxCount <= 0 ? Promise.reject(error) : request(url, maxCount - 1));
}
```

